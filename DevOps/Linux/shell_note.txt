bash

# 命令行编辑
    1、光标跳转
        ctr + left                  // 跳转到行首
        ctr + right                 // 跳转到行尾
        ctr + a                     // 跳转到行首
        ctr + e                     // 跳转到行尾
        
        ctr + u                     // 删除光标至行首的内容
        ctr + k                     // 删除光标至行尾的内容

        ctr + d                     // 删除光标后一位
        ctr + l                     // 清屏

# 命令历史
    top / bottom

# 命令替换      把命令中某个子命令替换为替换为其执行结果的过程
    方式:
        1、$(command)
        2、`command`
    demo:
        1、echo "The current directory is $(pwd)"
        2、touch ./file-$(date +%F-%H-%M-%S).txt        // 创建以当前时间为文件名的文件


#、文件名通配(globbing)
    glob 模式通常用来匹配目录以及文件，而不是文本
    语法:
        *:                                  // 匹配任意长度任意字符
        ?:                                  // 匹配任意一个字符
        []:                                 // 匹配指定范围内的任意单个字符  [abc] [a-z] [A-Z] [a-zA-Z] [0-9]
        [^]:                                // 匹配指定范围外的任意一个字符
        [!list] 	                        // 同[^list]
        {str1,str2,...} 	                // 匹配 srt1 或者 srt2 或者更多字符串，也可以是集合
    专用字符集:
        [:alnum:] 	                        // 任意数字或者字母
        [:alpha:] 	                        // 任意字母
        [:space:] 	                        // 空格
        [:lower:] 	                        // 小写字母
        [:upper:] 	                        // 任意大写字母        
        [:digit:] 	                        // 任意数字
        [:cntrl:] 	                        // 控制符
        [:graph:] 	                        // 图形
        [:print:] 	                        // 可打印字符
        [:punct:] 	                        // 标点符号
        [:xdigit:] 	                        // 十六进制数
        [:blank:] 	                        // 空白字符（未验证）
    demo:
    
        1、ls a*                            // 列出以a字母开头的文件
        2、ls a*3                           // 列出以a字母开头以3结尾的文件
        3、ls ?a*                           // 列出第二位字符为a的文件
        4、ls [a-zA-Z]*[0-9]                // 列出以字母开头数字结尾的文件
        5、ls [^0-9]*                       // 列出不以数字开头的文件
        6、ls [^0-9]*                       // 列出不以数字开头的文件
        7、ls [[:alpha:]]*[[:space:]]*[[:alpha:]]                       // 列出以字母开头以字母结尾中间保护空格的文件
        8、ls *[[:alnum:]]*                 // 列出包含非数字非字母的特殊符号的文件
#、Linux shell 元字符   
    IFS 	                                // 由 < space > 或 < tab > 或 < enter > 三者之一组成
    CR 	                                    // 由 < enter > 产生
    = 	                                    // 设定变量
    $ 	                                    // 作变量或运算替换
    > 	                                    // 重导向标准输出
    < 	                                    // 重导向标准输入
    | 	                                    // 命令管线
    & 	                                    // 重导向文件描述符，或将命令静默执行
    ( ) 	                                // 将其内的命令置于 nested subshell 执行，或用于运算或命令替换
    { } 	                                // 将其内的命令置于 non-named function 中执行，或用在变量替换的界定范围
    ; 	                                    // 在前一个命令结束时，而忽略其返回值，继续执行下一个命令
    && 	                                    // 在前一个命令结束时，若返回值为 true，继续执行下一个命令
    || 	                                    // 在前一个命令结束时，若返回值为 false，继续执行下一个命令
    ! 	                                    // 执行 history 中的命令

#、Tips
=============================================================================
    bash支持的引号:
        ``:命令替换             反引号
        "":弱引用               可以实现变量替换
        '':强引用               不可实现变量替换


#、linux上进程有5种状态:
    1. 运行(正在运行或在运行队列中等待)
    2. 中断(休眠中, 受阻, 在等待某个条件的形成或接受到信号)
    3. 不可中断(收到信号不唤醒和不可运行, 进程必须等待直到有中断发生)
    4. 僵死(进程已终止, 但进程描述符存在, 直到父进程调用wait4()系统调用后释放)
    5. 停止(进程收到SIGSTOP, SIGSTP, SIGTIN, SIGTOU信号后停止运行运行)

    ps工具标识进程的5种状态码:
    R 运行 runnable (on run queue)
    S 中断 sleeping   
    D 不可中断 uninterruptible sleep (usually IO)
    Z 僵死 a defunct (”zombie”) process
    T 停止 traced or stopped




#、shell编程
=============================================================================
静态语言:   
    编译型  强类型  运行前转换为可执行格式
    C、C++、Java、C#
动态语言:   
    解释型  弱类型  边解释边执行
    PHP、Shell、Python、
    脚本语言


变量
本地变量    VARNAME=VALUE           对整个bash进程有效
局部变量    local VARNAME=VALUE     作用域为当前代码段
环境变量    export VARNAME=VALUE    作用域为当前shell进程及其子shell进程
位置变量    $1、$2...
特殊变量
    $?      上一个命令执行状态返回值
            程序执行返回状态码  
                0:      正常执行
                1-255   错误执行    1、2、127系统预留

脚本在执行是会启动一个自shell进程
    命令行中启动的脚本会继承当前shell环境变量
    系统自动执行的脚本(非命令行启动)就需要自我定义需要各环境变量








